<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>두 직선의 평행과 수직 탐구 도구 (모바일 최적화)</title>
    
    <!-- KaTeX for LaTeX rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css" xintegrity="sha384-sCutvCsAPxVscKrymgk+cU32aD2v2V2T2OCVLhYw/1mH+r+w2e0bM4L2U2L1xG3B" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js" xintegrity="sha384-hIoIeY_KDAJQLbNnL2KiCoyhVTN4zC8U+s99G3VpS3rD9h/l5+24Y/YlV2Yd/dpt" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/auto-render.min.js" xintegrity="sha384-43gGktQ5PCwGZOcbM4iKj3y2fVfSj3Gz0iHihI+gVNT29qQ/sN6T2iFfV872TjBT" crossorigin="anonymous"></script>
        
    <!-- html2canvas for saving as image -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap');
        
        :root {
            --primary-color: #3f51b5;
            --secondary-color: #e8eaf6;
            --text-color: #333;
            --bg-color: #f0f4f8;
        }

        body {
            font-family: 'Noto Sans KR', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 10px;
        }
        h1, h2 {
            text-align: center;
            color: #1a237e;
        }
        h1 {
            font-size: 1.5em;
            border-bottom: 3px solid var(--primary-color);
            padding-bottom: 10px;
        }
        h2 {
            font-size: 1.2em;
        }

        #app-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 900px;
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            padding: 15px;
            margin: 0 auto;
            box-sizing: border-box;
        }
        
        #interactive-tool {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 20px;
        }
        #controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin: 15px 0;
            padding: 15px;
            background-color: var(--secondary-color);
            border-radius: 8px;
            width: 100%;
            box-sizing: border-box;
        }
        .input-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
            font-size: 1.1em;
        }
        .input-group input {
            width: 60px;
            padding: 10px;
            border: 2px solid #9fa8da;
            border-radius: 6px;
            text-align: center;
            font-size: 1em;
            transition: border-color 0.3s, box-shadow 0.3s;
        }
        .input-group input:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 5px rgba(63, 81, 181, 0.5);
        }
        .button-row {
            display: flex;
            justify-content: space-around;
            width: 100%;
            gap: 10px;
        }
        button {
            flex-grow: 1;
            padding: 12px 15px;
            font-size: 1em;
            font-weight: 500;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.1s;
        }
        button:active {
            transform: scale(0.98);
        }
        #btn-draw { background-color: #4caf50; }
        #btn-draw:hover { background-color: #43a047; }
        #btn-parallel { background-color: #2196f3; }
        #btn-parallel:hover { background-color: #1e88e5; }
        #btn-perpendicular { background-color: #f44336; }
        #btn-perpendicular:hover { background-color: #e53935; }

        #canvas-container {
            position: relative;
            width: 100%;
            max-width: 500px;
            aspect-ratio: 1 / 1;
            margin: 0 auto;
        }
        canvas {
            width: 100%;
            height: 100%;
            border: 2px solid #c5cae9;
            border-radius: 8px;
            background-color: #ffffff;
            cursor: crosshair;
            touch-action: none; /* Prevent default touch actions like scrolling */
        }
        .equation-display {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 5px 8px;
            border-radius: 6px;
            font-size: 0.9em;
            font-weight: bold;
            pointer-events: none;
            border: 1px solid #ddd;
        }
        #eq-base { top: 10px; left: 10px; color: #3f51b5; }
        #eq-para { top: 40px; left: 10px; color: #2196f3; }
        #eq-perp { top: 70px; left: 10px; color: #f44336; }
        #eq-drag { bottom: 10px; right: 10px; left: auto; color: #e65100; border: 2px dashed #e65100; }

        #inquiry-sheet {
            width: 100%;
            margin-top: 20px;
            padding-top: 15px;
            border-top: 2px solid #e0e0e0;
        }
        .info-inputs {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-bottom: 20px;
        }
        .info-inputs input {
            width: 100px;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        .question-block {
            margin-bottom: 15px;
            background-color: #f9f9f9;
            padding: 15px;
            border-radius: 8px;
            border-left: 5px solid #9fa8da;
        }
        .question-block p {
            margin: 0 0 10px 0;
            font-weight: 500;
            line-height: 1.5;
        }
        .question-block textarea {
            width: calc(100% - 20px);
            min-height: 100px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 1em;
            font-family: 'Noto Sans KR', sans-serif;
            resize: vertical;
        }
        #save-button-container {
            text-align: center;
            margin-top: 20px;
        }
        #btn-save {
            background-color: #7e57c2;
            font-size: 1.1em;
            padding: 12px 25px;
            width: 100%;
        }
        #btn-save:hover { background-color: #673ab7; }

        /* Larger screen adjustments */
        @media (min-width: 600px) {
            body {
                padding: 20px;
            }
            h1 { font-size: 2em; }
            h2 { font-size: 1.5em; }
            #controls {
                flex-direction: row;
                justify-content: center;
                align-items: center;
                gap: 10px;
            }
            .button-row {
                width: auto;
            }
            #btn-save {
                width: auto;
            }
        }
    </style>
</head>
<body>

    <div id="app-container">
        <h1>두 직선의 평행과 수직 탐구 도구</h1>

        <div id="interactive-tool">
            <div id="controls">
                <div class="input-group">
                    <span>$y = $</span>
                    <input type="number" id="slope-a" value="1">
                    <span>$x + $</span>
                    <input type="number" id="y-intercept-b" value="1">
                </div>
                <div class="button-row">
                    <button id="btn-draw">그리기</button>
                    <button id="btn-parallel">평행</button>
                    <button id="btn-perpendicular">수직</button>
                </div>
            </div>
            <div id="canvas-container">
                <canvas id="graph-canvas"></canvas>
                <div id="eq-base" class="equation-display" style="display:none;"></div>
                <div id="eq-para" class="equation-display" style="display:none;"></div>
                <div id="eq-perp" class="equation-display" style="display:none;"></div>
                <div id="eq-drag" class="equation-display" style="display:none;"></div>
            </div>
        </div>

        <div id="inquiry-sheet">
            <h2>탐구 활동지</h2>
            <div class="info-inputs">
                <input type="text" id="student-id" placeholder="학번">
                <input type="text" id="student-name" placeholder="이름">
            </div>

            <div class="question-block">
                <p>1. '평행' 버튼을 눌러 생성된 직선을 움직여보세요. 원래 직선과 비교하여 기울기와 y절편은 각각 어떻게 변하나요? 관찰한 점을 바탕으로, 두 직선이 평행할 조건을 정리해보세요.</p>
                <textarea placeholder="여기에 답을 입력하세요..."></textarea>
            </div>
            <div class="question-block">
                <p>2. '수직' 버튼을 눌러 생성된 직선을 움직여보세요. 원래 직선의 기울기와 어떤 관계가 있나요? 두 기울기의 곱을 계산해보고, 관찰한 점을 바탕으로 두 직선이 수직일 조건을 정리해보세요.</p>
                <textarea placeholder="여기에 답을 입력하세요..."></textarea>
            </div>
            <div class="question-block">
                <p>3. 원래 직선의 기울기가 0일 때(x축에 평행), 수직인 직선의 방정식은 어떤 형태로 나타나나요? 그 이유는 무엇일까요?</p>
                <textarea placeholder="여기에 답을 입력하세요..."></textarea>
            </div>
            <div class="question-block">
                <p>4. [심화] 두 직선 $y = m_1x + n_1$ 과 $y = m_2x + n_2$ 가 평행하지만 일치하지는 않을 조건은 무엇인가요?</p>
                <textarea placeholder="여기에 답을 입력하세요..."></textarea>
            </div>
            <div class="question-block">
                <p>5. [심화] 두 직선 $y = m_1x + n_1$ 과 $y = m_2x + n_2$ 가 수직일 조건은 무엇인가요? (단, 두 직선 모두 x축 또는 y축에 평행하지 않다고 가정)</p>
                <textarea placeholder="여기에 답을 입력하세요..."></textarea>
            </div>

            <h2>연습 문제</h2>
            <div class="question-block">
                <p>1. 직선 $y = 3x + 5$ 에 평행하고 점 $(1, 2)$를 지나는 직선의 방정식을 구하세요.</p>
                <textarea placeholder="정답을 y=ax+b 형태로 입력하세요."></textarea>
            </div>
            <div class="question-block">
                <p>2. 직선 $y = -\frac{1}{2}x - 1$ 에 수직이고 점 $(2, 3)$을 지나는 직선의 방정식을 구하세요.</p>
                <textarea placeholder="정답을 y=ax+b 형태로 입력하세요."></textarea>
            </div>
        </div>

        <div id="save-button-container">
            <button id="btn-save">탐구 활동지 이미지로 저장</button>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM Elements ---
            const canvas = document.getElementById('graph-canvas');
            const ctx = canvas.getContext('2d');
            const slopeInput = document.getElementById('slope-a');
            const interceptInput = document.getElementById('y-intercept-b');
            const drawBtn = document.getElementById('btn-draw');
            const parallelBtn = document.getElementById('btn-parallel');
            const perpendicularBtn = document.getElementById('btn-perpendicular');
            const saveBtn = document.getElementById('btn-save');
            
            const eqBaseDisp = document.getElementById('eq-base');
            const eqParaDisp = document.getElementById('eq-para');
            const eqPerpDisp = document.getElementById('eq-perp');
            const eqDragDisp = document.getElementById('eq-drag');

            // --- Canvas & Graph Setup ---
            let width, height, originX, originY;
            const scale = 25; // Adjusted scale for mobile
            let lines = []; // Array to store all line objects
            let baseLine = null;

            // --- Dragging State ---
            let isDragging = false;
            let selectedLine = null;

            // Line class to store properties
            class Line {
                constructor(m, b, color, isDraggable = false, type = 'base') {
                    this.m = m; // slope
                    this.b = b; // y-intercept
                    this.color = color;
                    this.isDraggable = isDraggable;
                    this.type = type; // 'base', 'parallel', 'perpendicular'
                    this.lineWidth = 2.5;
                }

                // Method to display the equation
                getEquation() {
                    const mStr = this.m.toFixed(2);
                    const bSign = this.b >= 0 ? '+' : '-';
                    const bStr = Math.abs(this.b).toFixed(2);
                    if (Math.abs(this.m) < 0.01) { // Horizontal line
                        return `y = ${this.b.toFixed(2)}`;
                    }
                    if (Math.abs(this.m) > 1000) { // Vertical line
                        return `x = ${(-this.b / this.m).toFixed(2)}`;
                    }
                    return `y = ${mStr}x ${bSign} ${bStr}`;
                }
            }

            // --- Initialization ---
            function setupCanvas() {
                const container = document.getElementById('canvas-container');
                width = container.clientWidth;
                height = container.clientHeight;
                canvas.width = width;
                canvas.height = height;
                originX = width / 2;
                originY = height / 2;
                redrawAll();
            }

            // --- Drawing Functions ---
            function drawGrid() {
                ctx.strokeStyle = '#e0e0e0';
                ctx.lineWidth = 1;
                for (let x = originX + scale; x < width; x += scale) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, height); ctx.stroke(); }
                for (let x = originX - scale; x > 0; x -= scale) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, height); ctx.stroke(); }
                for (let y = originY + scale; y < height; y += scale) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(width, y); ctx.stroke(); }
                for (let y = originY - scale; y > 0; y -= scale) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(width, y); ctx.stroke(); }
            }

            function drawAxes() {
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.beginPath(); ctx.moveTo(0, originY); ctx.lineTo(width, originY); ctx.stroke(); // X-axis
                ctx.beginPath(); ctx.moveTo(originX, 0); ctx.lineTo(originX, height); ctx.stroke(); // Y-axis
                ctx.fillStyle = '#000'; ctx.font = '14px Arial';
                ctx.fillText('x', width - 15, originY - 8);
                ctx.fillText('y', originX + 8, 15);
            }

            function drawLineOnCanvas(line) {
                ctx.beginPath();
                ctx.strokeStyle = line.color;
                ctx.lineWidth = line.lineWidth;
                const xMin = -originX / scale;
                const xMax = (width - originX) / scale;
                if (Math.abs(line.m) > 1000) {
                    const x_val = -line.b / line.m;
                    const canvasX = originX + x_val * scale;
                    ctx.moveTo(canvasX, 0); ctx.lineTo(canvasX, height);
                } else {
                    const y1 = line.m * xMin + line.b; const y2 = line.m * xMax + line.b;
                    const canvasX1 = originX + xMin * scale; const canvasY1 = originY - y1 * scale;
                    const canvasX2 = originX + xMax * scale; const canvasY2 = originY - y2 * scale;
                    ctx.moveTo(canvasX1, canvasY1); ctx.lineTo(canvasX2, canvasY2);
                }
                ctx.stroke();
            }
            
            function updateEquationDisplays() {
                eqBaseDisp.style.display = 'none'; eqParaDisp.style.display = 'none'; eqPerpDisp.style.display = 'none';
                lines.forEach(line => {
                    const eq = line.getEquation();
                    if (line.type === 'base') { eqBaseDisp.textContent = `기본: ${eq}`; eqBaseDisp.style.display = 'block'; } 
                    else if (line.type === 'parallel') { eqParaDisp.textContent = `평행: ${eq}`; eqParaDisp.style.display = 'block'; } 
                    else if (line.type === 'perpendicular') { eqPerpDisp.textContent = `수직: ${eq}`; eqPerpDisp.style.display = 'block'; }
                });
            }

            function redrawAll() {
                ctx.clearRect(0, 0, width, height);
                drawGrid();
                drawAxes();
                lines.forEach(line => drawLineOnCanvas(line));
                updateEquationDisplays();
            }

            // --- Event Handlers ---
            function handleDraw() {
                const m = parseFloat(slopeInput.value);
                const b = parseFloat(interceptInput.value);
                if (isNaN(m) || isNaN(b)) { alert('유효한 숫자를 입력해주세요.'); return; }
                baseLine = new Line(m, b, '#3f51b5', false, 'base');
                lines = [baseLine];
                redrawAll();
            }
            drawBtn.addEventListener('click', handleDraw);

            parallelBtn.addEventListener('click', () => {
                if (!baseLine) { alert('먼저 기본 그래프를 그려주세요.'); return; }
                lines = lines.filter(l => l.type !== 'parallel');
                const parallelLine = new Line(baseLine.m, baseLine.b + 3, '#2196f3', true, 'parallel');
                lines.push(parallelLine);
                redrawAll();
            });

            perpendicularBtn.addEventListener('click', () => {
                if (!baseLine) { alert('먼저 기본 그래프를 그려주세요.'); return; }
                lines = lines.filter(l => l.type !== 'perpendicular');
                let perp_m, perp_b;
                if (Math.abs(baseLine.m) < 0.01) { perp_m = 10000; perp_b = -perp_m * 1; } 
                else if (Math.abs(baseLine.m) > 1000) { perp_m = 0; perp_b = baseLine.b; } 
                else { perp_m = -1 / baseLine.m; perp_b = baseLine.b; }
                const perpLine = new Line(perp_m, perp_b, '#f44336', true, 'perpendicular');
                lines.push(perpLine);
                redrawAll();
            });

            saveBtn.addEventListener('click', () => {
                const studentName = document.getElementById('student-name').value || '학생';
                const studentId = document.getElementById('student-id').value || '0000';
                const filename = `${studentId}_${studentName}_탐구활동.png`;
                const appContainer = document.getElementById('app-container');
                const originalShadow = appContainer.style.boxShadow;
                appContainer.style.boxShadow = 'none';
                window.scrollTo(0, 0); // Scroll to top for full capture

                html2canvas(appContainer, {
                    scale: 1.5,
                    onclone: (doc) => {
                        if (window.renderMathInElement) {
                            renderMathInElement(doc.body, {
                                delimiters: [
                                    {left: '$$', right: '$$', display: true},
                                    {left: '$', right: '$', display: false},
                                ]
                            });
                        }
                    }
                }).then(canvas => {
                    const image = canvas.toDataURL('image/png');
                    const link = document.createElement('a');
                    link.href = image;
                    link.download = filename;
                    link.click();
                    appContainer.style.boxShadow = originalShadow;
                });
            });

            // --- Mouse & Touch Dragging Logic ---
            function getEventPosition(evt) {
                const rect = canvas.getBoundingClientRect();
                if (evt.touches && evt.touches.length > 0) {
                    return { x: evt.touches[0].clientX - rect.left, y: evt.touches[0].clientY - rect.top };
                }
                return { x: evt.clientX - rect.left, y: evt.clientY - rect.top };
            }
            
            function canvasToGraphCoords(pos) {
                return { x: (pos.x - originX) / scale, y: (originY - pos.y) / scale };
            }

            function handleDragStart(e) {
                const pos = getEventPosition(e);
                const graphPos = canvasToGraphCoords(pos);
                let minDistance = Infinity;
                let lineToSelect = null;
                lines.forEach(line => {
                    if (!line.isDraggable) return;
                    const distance = Math.abs(line.m * graphPos.x - graphPos.y + line.b) / Math.sqrt(line.m * line.m + 1);
                    if (distance < 0.8 && distance < minDistance) { // Increased tolerance for touch
                        minDistance = distance;
                        lineToSelect = line;
                    }
                });
                if (lineToSelect) {
                    isDragging = true;
                    selectedLine = lineToSelect;
                    selectedLine.lineWidth = 4.5;
                    redrawAll();
                    e.preventDefault(); // Prevent scrolling while dragging
                }
            }

            function handleDragMove(e) {
                if (isDragging && selectedLine) {
                    const pos = getEventPosition(e);
                    const graphPos = canvasToGraphCoords(pos);
                    if (Math.abs(selectedLine.m) > 1000) {
                        selectedLine.b = -selectedLine.m * graphPos.x;
                    } else {
                        selectedLine.b = graphPos.y - selectedLine.m * graphPos.x;
                    }
                    eqDragDisp.textContent = `현재: ${selectedLine.getEquation()}`;
                    eqDragDisp.style.display = 'block';
                    redrawAll();
                    e.preventDefault();
                }
            }

            function handleDragEnd() {
                if (isDragging) {
                    isDragging = false;
                    if(selectedLine) { selectedLine.lineWidth = 2.5; }
                    selectedLine = null;
                    eqDragDisp.style.display = 'none';
                    redrawAll();
                }
            }

            canvas.addEventListener('mousedown', handleDragStart);
            canvas.addEventListener('mousemove', handleDragMove);
            canvas.addEventListener('mouseup', handleDragEnd);
            canvas.addEventListener('mouseleave', handleDragEnd);

            canvas.addEventListener('touchstart', handleDragStart, { passive: false });
            canvas.addEventListener('touchmove', handleDragMove, { passive: false });
            canvas.addEventListener('touchend', handleDragEnd);
            canvas.addEventListener('touchcancel', handleDragEnd);

            // --- Initial Load ---
            setupCanvas();
            handleDraw(); // Draw initial graph
            if (window.renderMathInElement) {
                renderMathInElement(document.body, {
                    delimiters: [
                        {left: '$$', right: '$$', display: true},
                        {left: '$', right: '$', display: false}
                    ]
                });
            }
            window.addEventListener('resize', setupCanvas);
        });
    </script>
</body>
</html>
